Root = Stmt*

Name =
  'ident' | 'self'

LitVal =
  'string' | 'int_number'

FnDef =
  'fn' 'ident' '(' ')' Block

Block = '{' Stmt* '}'

Stmt =
  Expr ';'?
| DeclarationStmt ';'?
| WhileStmt
| ForStmt

BinExpr =
  lhs: Expr
  op: (
    '+' | '-' | '*' | '/' | '%'
    | '&' | '|' | '^'
    | '&&' | '||'
    | '=' | '+=' | '-=' | '*=' | '/=' | '%='
    | '&=' | '|=' | '^='
    | '&&=' | '||='
    | '==' | '!=' | '<' | '>' | '<=' | '>='
  )
  rhs: Expr

TupleExpr =
  '(' (Expr (',' Expr)* ','?)? ')'

ArrExpr =
  '[' (Expr (',' Expr)* ','?)? ']'

PrimaryExpr = inner: PrimaryExprInner

PrimaryExprInner =
  TupleExpr
| ArrExpr
| Block
| Name
| LitVal
| IfExpr
| BreakStmt
| ContinueStmt
| ReturnStmt

FnCallExpr = Expr FnCallArgs
MethodCallExpr = Expr '.' 'ident' FnCallArgs

FnCallArgs = '(' (Expr (',' Expr)* ','?)? ')'

PrefixUnaryExpr =
  op: (
    '+' | '-' | '!' | '~'
  )
  Expr

IndexExpr = Expr IndexExprBrackets

IndexExprBrackets = '[' Expr ']'

MemberAccessExpr = Expr '.' 'ident'

Expr =
  PrimaryExpr
| BinExpr
| PrefixUnaryExpr
| FnCallExpr
| IndexExpr
| MemberAccessExpr
| MethodCallExpr
| FnDef

IfBranch =
  'if' Expr Block

ElseIfBranch =
  'else' 'if' Expr Block

ElseBranch =
  'else' Block

IfExpr =
  IfBranch ElseIfBranch* ElseBranch?

WhileStmt =
  'while' Expr Block

ForStmt =
  'for' ForInExpr Block

ForInExpr =
  'ident' 'in' Expr

BreakStmt =
  'break' Expr?

ContinueStmt =
  'continue'

ReturnStmt =
  'return' Expr?

DeclarationStmt =
  'let' 'ident' '=' Expr